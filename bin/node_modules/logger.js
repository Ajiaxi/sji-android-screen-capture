/* [Usage]
 > var logger = require('./common/logger.js');

 > var log = logger.create(); //means only output to stderr (usually means console)
 > var log = logger.create( 'someDir/myLog.txt' ); //same as following code but with keepOldFileDays:0
 > var log = logger.create('someDir/myLog.txt', 2); //keepOldFileDays: 2

 >                                                                   log('msg'); or log('msg\n');
 23:59:59.999 msg\n
 >                                                                   log('msg1\nMsg2');
 23:59:59.999 msg1\n
 23:59:59.999 Msg2\n
 >                                                                   log('msg1\nMsg2', {head:'[myHead]'});
 23:59:59.999 [myHead]msg1\n
 23:59:59.999 [myHead]Msg2\n
 >                                                                   log('msg', {stderr:true});
 23:59:59.999 msg\n
 23:59:59.999 msg\n  (for stderr output, usually means console)
 >                                                                   log('processing...', {autoNewLine:false});
 >                                                                   log('done.', {autoNewLine:false});
 >                                                                   log('newLogMsg');
 23:59:59.998 processing...done.\n
 23:59:59.999 newLogMsg
 >                                                                   log.getLogFilePath()
 someDir/myLog_20131231.txt
 >                                                                   log.getLogFilePath(1)
 someDir/myLog_20131230.txt
 >                                                                   log.close()

 [Detail]
 Write log with head format '23:59:59.999 ' to each line head and new line appended.
 Fatal error will be output to stderr (usually means console).

 When use file output, the file will be created when day changes.
 When first output or day changed, it will open/create log file name like myLog_20131231.txt with append mode,
 and delete any file <= myLog_20131224.txt.
 */
'use strict';
var fs = require('fs'), path = require('path');

var head = '', date = new Date(0), dd = -1, re_basenameSuffix = /^_\d{8}$/; //_YYYYMMDD

function makeSuffix(dt) { //_YYYYMMDD   //note: must match re_basenameSuffix
  return '_' + dt.getFullYear() + dpad2(dt.getMonth() + 1) + dpad2(dt.getDate());
}
function dpad2(d) {
  return (d < 10) ? '0' + d : d.toString();
}
function dpad3(d) {
  return (d < 10) ? '00' + d : (d < 100) ? '0' + d : d.toString();
}

/*
 * create new log file for today and delete too old backup files
 */
function createNewLogFileForToday(context) {
  var minDate = new Date(date);
  minDate.setDate(dd - 1 - (Number(context.keepOldFileDays) || 0));
  var minSuffix = makeSuffix(minDate);
  var dir = path.dirname(context.filePath), ext = path.extname(context.filePath), base = path.basename(context.filePath, ext);
  /*
   * delete old log files
   */
  try {
    fs.readdirSync(dir).forEach(function (name) {
      if (path.extname(name) === ext) {
        var _base = path.basename(name, ext);
        if (_base.slice(0, base.length) === base) {
          var _suffix = _base.slice(base.length);
          if (_suffix <= minSuffix && re_basenameSuffix.test(_suffix)) {
            try {
              if (_suffix !== minSuffix || fs.statSync(dir + '/' + name).mtime.valueOf() <= minDate.valueOf()) {
                fs.unlinkSync(dir + '/' + name);
              }
            } catch (e) {
            }
          }
        }
      }
    });
  }
  catch (e) {
    if (e.code !== 'ENOENT') {
      process.stderr.write(head + 'Failed to search or delete old log files. ' + e + '\n');
    }
  }

  /*
   * create new log file for today
   */
  var todayLogFilePath = dir + '/' + base + makeSuffix(date) + ext;
  try {
    context.fd = fs.openSync(todayLogFilePath, 'a'); //use append mode for multi-process
  }
  catch (e) {
    process.stderr.write(head + 'Failed to open/create file with append mode. ' + e + '\n');
  }
}//end of createNewLogFileForToday


/**
 * write msg to log file or stderr
 * @param context
 * @param msg (any type)
 * @param option
 *    (
 *      autoNewLine: <Boolean> (default: true),
 *      head:        <String>  (default: ''),
 *      stderr:      <Boolean> (default: false)
 *    })
 */
function __log(context, msg, option) {
  var nowMs = Date.now();
  if (nowMs !== date.valueOf()) {
    date.setTime(nowMs);

    //make head '23:59:59.999 '
    head = dpad2(date.getHours()) + ':' + dpad2(date.getMinutes()) + ':' + dpad2(date.getSeconds()) + '.' + dpad3(date.getMilliseconds()) + ' ';

    //close current and create new log file if date changed
    if (context.filePath && date.getDate() !== dd) {
      dd = date.getDate();
      __close(context);
      createNewLogFileForToday(context);
    }
  }

  msg = String(msg);
  var actualHead = (option && option.head) ? (head + option.head) : head;

  //remove last new line char
  var origMsgIsEndedWithNewLine = (msg.charCodeAt(msg.length - 1) === 0xa);
  if (origMsgIsEndedWithNewLine) {
    var crCount = 0;
    while (msg.charCodeAt(msg.length - 2 - crCount) === 0xd)
      crCount++;
    msg = msg.slice(0, -1 - crCount);
  }

  //prepend head to each line. To disable this, just change to "var s = msg"
  var s = msg.replace(/\r*\n/g, '\n' + actualHead);

  if (context.isLineEnded) {
    s = actualHead + s;
  } else if (option.head !== context.wantedNextLineOptionHead) {
    s = ' ####\n' + actualHead + s;
  }
  if (origMsgIsEndedWithNewLine || !option || option.autoNewLine) {
    s += '\n';
    context.isLineEnded = true;
    context.wantedNextLineOptionHead = undefined;
  } else {
    context.isLineEnded = false;
    context.wantedNextLineOptionHead = option.head;
  }

  //write to file if filePath is specified
  var ok = false;
  if (context.fd !== -1) {
    try {
      ok = fs.writeSync(context.fd, s);
    } catch (e) {
      if (!context.err_write) {
        context.lastError = e.message;
        context.err_write = true;
        process.stderr.write(actualHead + 'Failed to append log to file. ' + e + '\n');
      }
    }
  }

  //write to stderr if failed or no filePath specified
  if (!ok || (option && option.stderr === true)) {
    try {
      process.stderr.write(s);
    } catch (e) {
      context.lastError = e.message;
    }
  }
  return true;
}

/**
 * create a log context and return a log function which has been bound to the context so can be called directly.
 * @param filePath
 * @param keepOldFileDays
 * @returns function log(msg, option {autoNewLine:<Boolean>, head:<String>, stderr:<Boolean>}). See __log
 */
function create(filePath, keepOldFileDays) {
  var context = {filePath: filePath, keepOldFileDays: keepOldFileDays, fd: -1, isLineEnded: true};

  //return a log function which has been bound to the context so can be called directly.
  var bound_func = function (msg, option) {
    return __log(context, msg, option);
  };

  bound_func.getLogFilePath = function (howManyDaysAgo/*optional*/) {
    var dir = path.dirname(context.filePath), ext = path.extname(context.filePath), base = path.basename(context.filePath, ext);
    return dir + '/' + base + makeSuffix(new Date(Date.now() - (Number(howManyDaysAgo) || 0) * 86400000)) + ext;
  };

  bound_func.close = function () {
    __close(context);
    context.filePath = null;
  };

  bound_func.nonEmpty = function (msg, option) {
    return msg && __log(context, msg, option);
  };

  return bound_func;
}

function __close(context) {
  if (context.fd !== -1) {
    try {
      fs.closeSync(context.fd);
    } catch (e) {
    }
    context.fd = -1;
    context.err_write = false;
  }
}

exports.create = create;
